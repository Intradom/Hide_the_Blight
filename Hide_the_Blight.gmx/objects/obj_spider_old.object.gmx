<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sp_spider_still</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setting Parameters
INCREMENT_THRESH = 0.1;
INVINCIBLE_PERIOD = 1;
MAX_GRAPPLE_LEN = global.CELL_SIZE * 3;
START_GRAV = 0.4;
WALK_MOVE_SPEED = 5;
JUMP_FORCE = 7;
GRAPPLE_MOVE_SPEED = 10;
HOOK_MOVE_SPEED = 19;
GRAPPLE_ACCEL = 0.25; // How much to oppose existing velocities when pulled by grapple hook
MAX_HEALTH = 5;
STARTING_HEALTH = 3;
GRAPPLE_CD = 1 // Seconds

// Global variables
health = STARTING_HEALTH;

// Member variables
grav = START_GRAV;
hsp = 0;
vsp = 0;
active = false; //dont want to draw any lines - don't want to grapple, when active, player is invincible
x_collision = false;
y_collision = false;
angle = 0;
xx = 0;
yy = 0;
found = noone;
started_hook = false;
invincible = false;
hook_avail = true;
transforming = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Executing Step Function

//which keys have been pressed?
//var key_right = keyboard_check(vk_right);
//var key_left = keyboard_check(vk_left);
//var key_jump = keyboard_check(vk_up);
var key_right = keyboard_check(vk_right) || keyboard_check(ord('D'));
var key_left = keyboard_check(vk_left) || keyboard_check(ord('A'));
var key_jump = keyboard_check(vk_up) || keyboard_check(ord('W'));



//DOWN ONE PIXEL check for the ground
if(place_meeting(x, y+1, obj_wall)){
    //stop moving vertically
    vsp = 0;
    sprite_index = sp_spider_still;
    //check for jump key pressed
    if(key_jump){
        sprite_index = sp_spider_jump;
        vsp = -jsp;
    }
} else{
    //adding gravity, if havent reached terminal velocity (which is 10) 
    if(vsp &lt; 10){
        vsp += grav;
    }
}

//Move right
if(key_right){
    hsp = spd;
    if (vsp == 0)
    {
        sprite_index = sp_spider_walk;
        image_xscale = 1;
    }
}


//moving left
if(key_left){
    hsp = -spd;
    if (vsp == 0)
    {
        sprite_index = sp_spider_walk;
        image_xscale = -1;
    }
}

//check for not moving, havent pressed either key or pressed both
if((!key_right &amp;&amp; !key_left) || (key_right &amp;&amp; key_left)){
    hsp = 0;
}


//horizontal collisions, next spot we move to has a solid?
if(place_meeting(x+hsp, y, obj_wall)){
    //while we're not touching that solid (only one pixel over) at a time
    //prevents us from moving INSIDE the wall
    while(!place_meeting(x+sign(hsp), y, obj_wall)){
        x+= sign(hsp);
    }
    hsp = 0;
}

//move horizontally
x += hsp;

//vertical collisions, next spot we move to has a solid?
if(place_meeting(x, y + vsp, obj_wall)){
    //while we're not touching that solid (only one pixel over) at a time
    //prevents us from moving INSIDE the wall
    while(!place_meeting(x, y + sign(vsp), obj_wall)){
        y+= sign(vsp);
    }
    vsp = 0;
}

//move vertically
y += vsp;



//CODE FOR GRAPPLING HOOK

//checking left mouse pressed
if(mouse_check_button_pressed(mb_left)){
    //setting the coordinates of the grappling hook
    mx = mouse_x;
    my = mouse_y;
    
    var len = 0;
    angle = point_direction(x, y, mx, my);
    var xx = x;
    var yy = y;
    while (len &lt; MAX_SEARCH_LENGTH)
    {
        xx = xx + lengthdir_x(len, angle);
        yy = yy + lengthdir_y(len, angle);
        var found = collision_line(x, y, xx, yy, obj_wall, false, true);
        if found != noone
            break;
        len += 1;
    }

    if instance_exists(found)
    {
        mx = xx;
        my = yy;
        active = true;
    }
}


if(active){
    //grav = 0.1;
    if(place_meeting(x, y, obj_wall)){
        grav = 0;
    }
    
    if(!place_meeting(x, y + ((my - y) * (0.06)), obj_wall)){
        y += (my - y) * (0.06);
    }
    else{
        grav = 0;
        
    }
    if(!place_meeting(x + ((mx - x) * (0.06)), y, obj_wall)){
        x += (mx - x) * (0.06);
    }
    else{
        grav = 0;
    }
}
else{
    grav = 0.4;
}


//checking when you release the mouse
if(mouse_check_button_released(mb_left)){
    //shouldn't be actively grappling when the mouse isn't pressed
    active = false;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

if(active){
    var len = 1;
    angle = point_direction(x, y, mx, my);
    var xx = x;
    var yy = y;
    while (len &lt; 100)
    {
        xx = xx + lengthdir_x(len, angle);
        yy = yy + lengthdir_y(len, angle);
        var stop = collision_line(x, y, xx, yy, obj_wall, true, true);
        
        if stop != noone break;
        
        draw_line(x, y, xx, yy);
        
        len += 1;
    }
    grav = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
