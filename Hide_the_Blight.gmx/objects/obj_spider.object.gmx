<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sp_spider_still</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setting Parameters
INCREMENT_THRESH = 0.1;
MAX_GRAPPLE_LEN = 1000;
START_GRAV = 1.0;
WALK_MOVE_SPEED = 5;
JUMP_FORCE = 15;
GRAPPLE_MOVE_SPEED = 10;
HOOK_MOVE_SPEED = 19;
GRAPPLE_ACCEL = 0.25; // How much to oppose existing velocities when pulled by grapple hook
MAX_HEALTH = 5;
STARTING_HEALTH = 3;
GRAPPLE_CD = 1 // Seconds

// Member variables
grav = START_GRAV;
hsp = 0;
vsp = 0;
active = false; //dont want to draw any lines - don't want to grapple, when active, player is invincible
x_collision = false;
y_collision = false;
angle = 0;
xx = 0;
yy = 0;
found = noone;
started_hook = false;
invincible = false;
hook_avail = true;
transforming = false;

// Create screen block
screen_block = instance_create(x, y, obj_screen_block);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hook_avail = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
///Executing Step Function

//which keys have been pressed?
var key_right = keyboard_check(vk_right) || keyboard_check(ord('D'));
var key_left = keyboard_check(vk_left) || keyboard_check(ord('A'));
var key_jump = keyboard_check(vk_up) || keyboard_check(ord('W'));

//DOWN ONE PIXEL check for the ground
if(place_meeting(x, y+1, obj_wall)){
    //stop moving vertically
    vsp = 0;
    //check for jump key pressed
    if(key_jump){
        vsp = -JUMP_FORCE;
    }
} else{
    //adding gravity, if havent reached terminal velocity (which is 10) 
    if(vsp &lt; 10){
        vsp += grav;
    }
}

//Move right
if(key_right){
    hsp = WALK_MOVE_SPEED;
}

//moving left
if(key_left){
    hsp = -WALK_MOVE_SPEED;
}

//check for not moving, havent pressed either key or pressed both
if((!key_right &amp;&amp; !key_left) || (key_right &amp;&amp; key_left)){
    hsp = 0;
}

//horizontal collisions, next spot we move to has a solid?
if(place_meeting(x+hsp, y, obj_wall)){
    //while we're not touching that solid (only one pixel over) at a time
    //prevents us from moving INSIDE the wall
    while(!place_meeting(x+sign(hsp), y, obj_wall)){
        x+= sign(hsp);
    }
    hsp = 0;
}

//vertical collisions, next spot we move to has a solid?
if(place_meeting(x, y + vsp, obj_wall)){
    //while we're not touching that solid (only one pixel over) at a time
    //prevents us from moving INSIDE the wall
    while(!place_meeting(x, y + sign(vsp), obj_wall)){
        y+= sign(vsp);
    }
    vsp = 0;
}

if (!active) // Don't allow character movement while grappling hook active
{
    //move horizontally
    x += hsp;
    //move vertically
    y += vsp;
}

/* GRAPPLING HOOK */

//checking left mouse pressed
if(mouse_check_button_pressed(mb_left) &amp;&amp; hook_avail)
{
    if (mouse_x &lt; x)
        image_xscale = -1;
    else
        image_xscale = 1;

    xx = x;
    yy = y;
    angle = point_direction(x, y, mouse_x, mouse_y);
    started_hook = true;
    found = noone;
    hook_avail = false;
    alarm[1] = GRAPPLE_CD * room_speed;
}

if (point_distance(x, y, xx, yy) &gt; MAX_GRAPPLE_LEN)
    started_hook = false;

// Hook is traveling outwards
if (started_hook &amp;&amp; !active)
{
    found = position_meeting(xx, yy, obj_wall);
    for (var i = 0; i &lt; HOOK_MOVE_SPEED &amp;&amp; !found; i++)
    {
        xx += lengthdir_x(1, angle);
        yy += lengthdir_y(1, angle);
        found = position_meeting(xx, yy, obj_wall);
    }

    if (found)
    {
        active = true;
        // Turn off gravity while moving
        grav = 0;
    }
}

if(active)
{   
    var total_spd = abs(vsp) + abs(hsp);
    if (total_spd &gt; 0)
    {
        hsp += -hsp / total_spd * GRAPPLE_ACCEL;
        vsp += -vsp / total_spd * GRAPPLE_ACCEL;
    }
    if (hsp &lt; INCREMENT_THRESH)
        hsp = 0;
    if (vsp &lt; INCREMENT_THRESH)
        vsp = 0;
        
    // Move towards hook target
    var move_angle = point_direction(x, y, xx, yy);
    var x_offset = lengthdir_x(GRAPPLE_MOVE_SPEED, move_angle);
    var y_offset = lengthdir_y(GRAPPLE_MOVE_SPEED, move_angle);
    if (!place_meeting(x + x_offset, y + y_offset, obj_wall))
    {
        x += x_offset;
        y += y_offset;
    }
    else // Move slowly towards wall
    {
        move_angle = point_direction(x, y, xx, yy);
        while (!place_meeting(x + lengthdir_x(INCREMENT_THRESH, move_angle), y, obj_wall))
        {
            x += lengthdir_x(INCREMENT_THRESH, move_angle);
            y += lengthdir_y(INCREMENT_THRESH, move_angle);
            move_angle = point_direction(x, y, xx, yy);
        }
    }
}

//checking when you release the mouse
if(mouse_check_button_released(mb_left)){
    grav = START_GRAV;
    //shouldn't be actively grappling when the mouse isn't pressed
    started_hook = false;
    active = false;
    sprite_index = sp_spider_still;
    found = noone;
}

// Change sprites
if (!started_hook &amp;&amp; !active)
{
    if (vsp &lt; 0)
        sprite_index = sp_spider_jump;
    else if (vsp &gt; 0)
        sprite_index = sp_spider_still;
    else if (hsp == 0)
        sprite_index = sp_spider_still;    
    else
    {
        if (sprite_index != sp_spider_walk)
        {
            sprite_index = sp_spider_walk;
            image_speed = 1;
        }
    }
    
    if (hsp &gt; 0)
        image_xscale = 1;
    else if (hsp &lt; 0)
        image_xscale = -1;
}

// Move screen block
screen_block.x = x;
screen_block.y = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_bug">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room_next(room) != -1)
{
    if (audio_is_playing(snd_horror))
        audio_stop_sound(snd_horror);
    room_goto(room_next(room));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>331</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_restart_game</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(started_hook){
    draw_line(x, y - sprite_height / 2, xx, yy);
}

draw_self();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
